# CPU Project - NANDからCPUを作る

## 概要
このプロジェクトは、NAND ゲートなど基本的な論理ゲートからスタートし、順序回路・演算器・レジスタファイルを経て、最終的にシングルサイクルCPUまでを段階的に構築する学習目的のプロジェクトです。

## CPU構成

### アーキテクチャ概要
- **ビット幅**: 8ビット
- **レジスタ数**: 8本（R0〜R7、R0は常に0固定）
- **命令メモリ**: 8エントリのROM
- **実行モデル**: シングルサイクル（1クロックで Fetch → Decode → Execute → WriteBack）
- **分岐**: なし（PCは常に+1インクリメント）

### 命令セットアーキテクチャ（ISA）

#### 命令フォーマット（8ビット）
```
[7:5] opcode  - ALU操作コード (3ビット)
[4:3] rd      - 書き込み先レジスタ番号 (2ビット, R0〜R3)
[2:0] rs      - 読み出し元レジスタ番号 (3ビット, R0〜R7)
```

#### サポート命令
| opcode | ニーモニック | 動作 |
|--------|------------|------|
| 000 | ADD | rd ← rd + rs |
| 001 | SUB | rd ← rd - rs |
| 010 | AND | rd ← rd & rs |
| 011 | OR  | rd ← rd \| rs |
| 100 | XOR | rd ← rd ^ rs |
| 101 | NOT | rd ← ~rd |
| 110 | - | 予約 |
| 111 | - | 予約 |

### データパス構成

```
┌─────────────────────────────────────────────────────────────┐
│                    シングルサイクルCPU                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌────┐  +1   ┌────────┐                                    │
│  │ PC │──────▶│ Adder  │                                    │
│  └─┬──┘       └───┬────┘                                    │
│    │              │                                          │
│    │    ┌─────────▼─────┐                                   │
│    │    │   MUX (常に+1) │                                   │
│    │    └────────┬───────┘                                   │
│    │             │                                           │
│    │    ┌────────▼────────┐  CLK/RST                        │
│    │    │  PC Register    │◀─────────                       │
│    │    └─────────────────┘                                  │
│    │                                                          │
│    │ [2:0]                                                    │
│    ▼                                                          │
│  ┌──────────┐                                                │
│  │   ROM    │  8エントリ × 8ビット                            │
│  │  (命令)   │                                                │
│  └────┬─────┘                                                │
│       │ [7:0] INST                                           │
│       ▼                                                       │
│  ┌──────────┐                                                │
│  │ Decoder  │  opcode[2:0], rd[2:0], rs[2:0]                │
│  └─┬────┬───┘                                                │
│    │    │                                                     │
│    │    │         ┌─────────────────┐                        │
│    │    └────────▶│  Register File  │  8×8bit, 2R1W         │
│    │              │   (regfile8x8)  │  R0 = 0固定            │
│    │      RA1(rd)─┤ RD1             │                        │
│    │      RA2(rs)─┤ RD2             │                        │
│    │      WA(rd) ─┤                 │                        │
│    │              └────┬────┬───────┘                        │
│    │                   │    │                                 │
│    │              RD1  │    │ RD2                             │
│    │                   ▼    ▼                                 │
│    │              ┌────────────┐                              │
│    └─────────────▶│    ALU8    │  ADD/SUB/AND/OR/XOR/NOT     │
│           opcode  └──────┬─────┘  zero/carry フラグ          │
│                          │ result                             │
│                          │                                    │
│                          └─────────┐                          │
│                                    │                          │
│                          WD ◀──────┘                          │
│                          (書き戻し)                             │
└───────────────────────────────────────────────────────────────┘
```

### 回路階層

#### 1. 基本ゲート層 (`src/gates/`)
- NAND, NOT, AND, OR, XOR, XNOR, NOR
- 多入力: AND3, OR3
- 定数: const_high, const_low

#### 2. 順序回路層 (`src/ff/`)
- SR Latch → D Latch → D Flip-Flop (master-slave)
- 同期リセット対応

#### 3. レジスタ層 (`src/reg/`)
- `reg8`: 8ビットレジスタ（WE付き）
- `regfile8x8`: 8本×8ビット、2読出1書込ポート、R0固定ゼロ

#### 4. 演算器層 (`src/alu/`)
- `half_adder`, `full_adder` → `adder8`（8ビット加算器）
- `alu1`: 1ビットALU（学習用、1-hotデコード）
- `alu8`: 8ビットALU（ADD/SUB/AND/OR/XOR/NOT、zero/carryフラグ）

#### 5. メモリ層 (`src/mem/`)
- `rom8x8`: 8エントリ×8ビット命令ROM（組合せ読出）

#### 6. 制御層 (`src/control/`)
- `decoder`: 命令デコーダ（opcode/rd/rs抽出）

#### 7. プロセッサ層 (`src/cpu/`)
- `cpu_simple`: シングルサイクルCPU統合モジュール

#### 8. その他 (`src/mux/`, `src/pc/`)
- `mux2`, `mux4`: セレクタ
- `pc8`: プログラムカウンタ（+1インクリメント、同期リセット）

### 動作シーケンス

1. **Fetch**: PC[2:0]でROMから命令読み出し
2. **Decode**: 命令をopcode/rd/rsに分解
3. **Read**: レジスタファイルからRD1(rd), RD2(rs)を読み出し
4. **Execute**: ALU8でRD1 op RD2を計算
5. **WriteBack**: 結果をrdに書き戻し（R0は無視）
6. **PC更新**: PC ← PC + 1

※ 全て1クロックサイクルで完結

### テスト環境

#### テストベンチ構成
- `sim/tb_gates/`: 基本ゲートテスト
- `sim/tb_alu/`: 加算器・ALUテスト
- `sim/tb_ff/`: ラッチ・FFテスト
- `sim/tb_reg/`: レジスタ・レジスタファイルテスト
- `sim/tb_mux/`: マルチプレクサテスト
- `sim/tb_pc/`: プログラムカウンタテスト
- `sim/tb_fetch/`: フェッチ動作テスト
- `sim/tb_cpu/`: CPU統合テスト

#### シミュレーション実行
```bash
# 特定のテストベンチを実行
make TB=tb_cpu_simple

# 波形ファイル生成先
sim/waveforms/*.vcd
```

### 学習ポイント

1. **ゲートレベル設計**: NANDからすべての論理を構築
2. **同期リセット**: クロックエッジでリセット反映（教育的に明確）
3. **1-hotデコード**: opcodeのミンターム生成→ゲート→OR合成
4. **階層的MUX**: 多入力選択を2入力MUXツリーで実現
5. **シングルサイクルパス**: フェッチから書き戻しまで1クロック
6. **R0ゼロ固定**: 多くのISA（MIPS等）で見られる設計パターン

### 今後の拡張候補

- [ ] 分岐命令（条件付きPC更新）
- [ ] 即値ロード命令（LI）
- [ ] メモリアクセス（LOAD/STORE + RAM追加）
- [ ] パイプライン化（5段: IF/ID/EX/MEM/WB）
- [ ] 割り込み対応
- [ ] マルチサイクル実行

---

## ビルド・実行

```bash
# すべてのソースをビルドして特定のテストベンチを実行
make TB=<テストベンチ名>

# 例: CPU統合テスト
make TB=tb_cpu_simple
```

## 依存ツール

- Icarus Verilog (iverilog)
- VVP (Verilog simulator)
- GTKWave (波形ビューア、オプション)
